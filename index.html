<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>전문 영화 큐레이션 서비스 선택 (레이아웃 복구 및 검색 확인)</title>
    <!-- Tailwind CSS CDN 로드 -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 사용자 정의 CSS 및 디자인 변수 설정 -->
    <style>
        /* ---------------------------------------------------- */
        /* === 디자인 설정 변수 (사용자 수정 영역) === */
        /* ---------------------------------------------------- */
        :root {
            /* 1. 기본 배경색 및 전체 테마 (Primary Background & Theme) */
            --main-bg-color: #111111;  /* 전체 페이지 배경색 (현재: 거의 검정) */
            --app-bg-color: #000000;   /* 메인 컨테이너 배경색 (현재: 검정) */
            --text-color: #ffffff;     /* 기본 글자색 (현재: 흰색) */
            
            /* 2. 강조색 및 버튼 (Accent Color & Buttons) */
            --accent-color: #ffffff;   /* 버튼 및 강조 요소의 기본 색상 (현재: 흰색) */
            --accent-text-color: #111111; /* 강조색 위 글자색 (현재: 검정) */
            --card-border-color: #333333; /* 카드/블록 테두리 색상 (현재: 짙은 회색) */
            
            /* 3. 카드 및 입력 필드 배경색 (Card & Input Background) */
            --card-bg-color: #1a1a1a;  /* 서비스 선택 카드, 입력 폼 배경색 (현재: 매우 짙은 회색) */
            --input-bg-color: #262626; /* 입력 필드 내부 배경색 (현재: 더 짙은 회색) */
        }
        
        /* ---------------------------------------------------- */
        /* === 폰트 설정 (수정 가능) === */
        /* ---------------------------------------------------- */
        /* Oswald: 제목용 폰트 (고딕 계열, 굵고 모던함) */
        /* Inter: 본문용 폰트 (깔끔한 고딕) */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300..700&family=Oswald:wght@500..700&display=swap');
        
        body { 
            font-family: 'Inter', sans-serif; 
            background-color: var(--main-bg-color); /* 배경색 적용 */
            color: var(--text-color); /* 기본 글자색 적용 */
        }
        
        h1, h2, h4 {
            font-family: 'Oswald', sans-serif; 
            letter-spacing: -0.05em; /* 제목 글자 간격 좁게 */
        }
        
        /* ---------------------------------------------------- */
        /* === 주요 요소 디자인 (클래스 설명 참고하여 수정) === */
        /* ---------------------------------------------------- */
        
        /* 메인 컨테이너 스타일 */
        .main-container-block {
            border: 1px solid var(--card-border-color); /* 테두리색 적용 */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.2);
            background-color: var(--app-bg-color); /* 메인 컨테이너 배경색 적용 */
        }
        
        /* 추천 결과 출력 블록 (흰색 테마) */
        #recommendationOutput {
            /* 추천 결과 블록은 특별히 흰색(bg-white)으로 유지하고, 짙은 그림자를 줍니다. */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5), 0 4px 6px -2px rgba(0, 0, 0, 0.05); 
            border: none;
        }
        
        /* 키워드 태그 스타일 (선택되지 않은 상태) */
        .keyword-tag {
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
            border: 1px solid var(--card-border-color); /* 테두리색 적용 */
            background-color: var(--card-bg-color); /* 태그 배경색 적용 */
            color: #ddd; /* 글자색 살짝 연하게 */
        }
        
        /* 키워드 태그 (선택된 상태) */
        .keyword-tag.selected {
            transform: scale(1.05);
            background-color: var(--accent-color); /* 강조색 적용 */
            color: var(--accent-text-color); /* 강조색 위 글자색 적용 */
            border-color: var(--accent-color);
            font-weight: 600;
        }
        
        /* 메인 액션 버튼 스타일 */
        .main-action-btn {
            background-color: var(--accent-color); /* 강조색 적용 */
            color: var(--accent-text-color); /* 강조색 위 글자색 적용 */
            transition: background-color 0.2s, color 0.2s;
            border-bottom: 2px solid #555; /* 버튼 아래 그림자/경계 */
        }
        .main-action-btn:hover {
            background-color: #dddddd; /* 마우스 오버 시 색상 (직접 수정 가능) */
        }

    </style>
</head>
<body class="min-h-screen p-4 md:p-8">

    <!-- ========================================================================= -->
    <!-- [A] 메인 컨테이너: 전체 크기 및 배경 설정 -->
    <!-- ========================================================================= -->
    <div id="app" class="max-w-5xl mx-auto main-container-block rounded-lg p-6 md:p-12 border-t-4 border-white/50">
        <!-- 
            - max-w-5xl: 최대 너비 설정 (xl 사이즈)
            - mx-auto: 가로 중앙 정렬
            - main-container-block: CSS 변수가 적용된 배경/테두리 스타일
            - rounded-lg: 모서리 둥글기 (large)
            - p-6 md:p-12: 내부 패딩 (모바일: p-6, 데스크탑: p-12)
            - border-t-4 border-white/50: 상단에 4px 두께의 흰색(50% 투명도) 경계선 
        -->
        
        <!-- [A-1] 헤더 영역: 제목 및 설명 -->
        <header class="mb-12 text-center">
            <!-- 제목 글자 크기, 굵기, 색상 -->
            <h1 class="text-6xl font-bold text-white mb-2">Personal CuratoR</h1>
            <!-- 설명 글자 크기, 색상, 굵기 -->
            <p class="text-lg text-gray-400 font-light">맞춤형 영화 추천 서비스</p>
        </header>

        <!-- ========================================================================= -->
        <!-- [B] 서비스 선택 화면 (초기 화면) -->
        <!-- ========================================================================= -->
        <div id="selectionView" class="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <!-- grid-cols-1: 모바일에서는 1열, lg:grid-cols-2: 데스크탑에서는 2열 -->
            <!-- gap-6: 카드 간 간격 -->
            
            <!-- [B-1] 카드 1: Vibe 기반 추천 -->
            <div id="selectVibe" class="modern-block p-8 rounded-lg border border-gray-800 hover:border-gray-500 transition duration-300 cursor-pointer" style="background-color: var(--card-bg-color);" data-service="vibe">
                <div class="text-gray-200 mb-4">
                    <!-- 아이콘 (SVG) -->
                    <svg class="w-10 h-10 mx-auto" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M15 10l4.55 2.275a.5.5 0 010 .89L15 15.65V10zM5.5 10h9M5.5 15h9M12 21a9 9 0 100-18 9 9 0 000 18z"></path></svg>
                </div>
                <h2 class="text-3xl font-bold text-center text-white mb-3">시청 기록 기반 (VIBE)</h2>
                <p class="text-gray-300 text-center font-light">좋아하는 영화들에서 공통된 분위기를 추출하여,<br>그 분위기에 가장 완벽하게 맞는 새로운 영화를 추천받습니다.</p>
                <button class="main-action-btn mt-6 w-full py-3 rounded-md font-semibold text-base">
                    이 모드 선택하기
                </button>
            </div>

            <!-- [B-2] 카드 2: Keyword 기반 추천 -->
            <div id="selectKeyword" class="modern-block p-8 rounded-lg border border-gray-800 hover:border-gray-500 transition duration-300 cursor-pointer" style="background-color: var(--card-bg-color);" data-service="keyword">
                <div class="text-gray-200 mb-4">
                    <!-- 아이콘 (SVG) -->
                    <svg class="w-10 h-10 mx-auto" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M14 10a2 2 0 10-4 0m4 0h3a2 2 0 012 2v10H5V12a2 2 0 012-2h3M9 6h6"></path></svg>
                </div>
                <h2 class="text-3xl font-bold text-center text-white mb-3">키워드 기반 (NARROW)</h2>
                <p class="text-gray-300 text-center font-light">원하는 장르, 분위기, 주제 등의 조건을 직접 입력하거나<br>목록에서 정교하게 선택하여 맞춤형 목록을 제공받습니다.</p>
                <button class="main-action-btn mt-6 w-full py-3 rounded-md font-semibold text-base">
                    이 모드 선택하기
                </button>
            </div>
        </div>

        <!-- ========================================================================= -->
        <!-- [C] 모드 선택 후의 공통 뷰 (폼, 로딩, 결과 포함) -->
        <!-- ========================================================================= -->
        <div id="serviceView" class="hidden mt-10 border-t border-gray-800 pt-8">
            <!-- mt-10: 상단 마진, border-t: 상단 경계선, pt-8: 상단 패딩 -->
            
            <!-- [C-1] 뒤로가기 버튼 -->
            <button id="backToSelection" class="text-gray-500 hover:text-white mb-8 flex items-center transition duration-200 text-sm font-medium">
                <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg>
                메인 서비스 선택으로 돌아가기
            </button>
            
            <!-- 현재 서비스 모드 제목 -->
            <h2 id="serviceTitle" class="text-4xl font-bold mb-10 text-center text-white uppercase"></h2>
            
            <!-- [C-2] 로딩 인디케이터 (영화 분석 중...) -->
            <div id="loading" class="text-center py-12 hidden">
                <div class="animate-spin rounded-full h-12 w-12 border-b-4 border-white/50 mx-auto mb-4"></div>
                <p class="text-gray-400 font-semibold text-xl" id="loadingText">영화 데이터를 분석 중입니다...</p>
            </div>

            <!-- ========================================================================= -->
            <!-- [D] 1. VIBE 모드 입력 폼 (수정됨: 동적 입력 칸 추가 및 최소 1개 입력 허용) -->
            <!-- ========================================================================= -->
            <div id="vibeForm" class="hidden max-w-2xl mx-auto space-y-5 p-6 rounded-lg modern-block" style="background-color: var(--card-bg-color);">
                <!-- 안내 문구 수정: 최소 1개, 입력 개수 무제한 -->
                <p class="text-gray-300 font-medium text-base border-b border-gray-700 pb-4">최소 1개 이상의 영화 제목을 입력해주세요. (입력 개수에 제한 없음)</p>
                
                <!-- 입력 필드 컨테이너 -->
                <div id="vibeInputsContainer" class="space-y-4">
                    <!-- 초기 3개 입력 필드 -->
                    <input type="text" data-movie-input placeholder="좋아하는 영화 1 (필수)" class="vibe-movie-input w-full p-4 border border-gray-700 rounded-md focus:ring-white/50 focus:border-white/50 text-white placeholder-gray-500" style="background-color: var(--input-bg-color);">
                    <input type="text" data-movie-input placeholder="좋아하는 영화 2 (선택)" class="vibe-movie-input w-full p-4 border border-gray-700 rounded-md focus:ring-white/50 focus:border-white/50 text-white placeholder-gray-500" style="background-color: var(--input-bg-color);">
                    <input type="text" data-movie-input placeholder="좋아하는 영화 3 (선택)" class="vibe-movie-input w-full p-4 border border-gray-700 rounded-md focus:ring-white/50 focus:border-white/50 text-white placeholder-gray-500" style="background-color: var(--input-bg-color);">
                </div>
                
                <!-- 입력 필드 추가 버튼 -->
                <button id="addVibeMovieInputBtn" class="w-full py-2 rounded-md font-medium text-sm border-2 border-gray-600 text-gray-400 hover:border-white hover:text-white transition duration-200 mt-2">
                    + 영화 입력 칸 추가하기
                </button>

                <button id="getVibeRecommendationBtn" class="main-action-btn w-full py-4 rounded-md font-bold text-lg transition duration-300 shadow-xl mt-6 flex items-center justify-center">
                    <span id="vibeBtnText">유사한 영화 5편 추천받기</span>
                    <div id="vibeSpinner" class="animate-spin rounded-full h-5 w-5 border-b-2 ml-2 hidden" style="border-bottom-color: var(--accent-text-color);"></div>
                </button>
            </div>

            <!-- ========================================================================= -->
            <!-- [E] 2. KEYWORD 모드 서브 선택 화면 (직접 입력 vs 목록 선택) -->
            <!-- ========================================================================= -->
            <div id="keywordSubSelectionView" class="hidden max-w-3xl mx-auto space-y-6">
                <h3 class="text-2xl font-semibold text-center text-white border-b border-gray-700 pb-4">키워드 입력 방식 선택</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-5">
                    <!-- 서브 선택 카드 1: 직접 입력 -->
                    <div id="selectDirectInput" class="modern-block p-6 rounded-lg border border-gray-800 hover:border-white/50 transition duration-300 cursor-pointer" style="background-color: var(--card-bg-color);">
                        <h4 class="text-xl font-bold text-white mb-2">A. 키워드 직접 입력 (자유 서술)</h4>
                        <p class="text-gray-400 text-sm">원하는 분위기나 조건을 자유롭게 서술합니다.</p>
                        <button class="main-action-btn mt-4 w-full py-2 rounded-md font-medium text-sm">
                            직접 입력 모드 시작
                        </button>
                    </div>
                    <!-- 서브 선택 카드 2: 목록에서 선택 -->
                    <div id="selectKeywordList" class="modern-block p-6 rounded-lg border border-gray-800 hover:border-white/50 transition duration-300 cursor-pointer" style="background-color: var(--card-bg-color);">
                        <h4 class="text-xl font-bold text-white mb-2">B. 목록에서 키워드 선택 (정교함)</h4>
                        <p class="text-gray-400 text-sm">제공되는 리스트에서 원하는 키워드만 골라 선택합니다.</p>
                        <button class="main-action-btn mt-4 w-full py-2 rounded-md font-medium text-sm">
                            선택 모드 시작
                        </button>
                    </div>
                </div>
            </div>


            <!-- ========================================================================= -->
            <!-- [F] 2A. KEYWORD 직접 입력 폼 -->
            <!-- ========================================================================= -->
            <div id="keywordForm" class="hidden max-w-2xl mx-auto space-y-5 p-6 rounded-lg modern-block" style="background-color: var(--card-bg-color);">
                <p class="text-gray-300 font-medium text-base border-b border-gray-700 pb-4">원하는 영화의 분위기, 장르 등 구체적인 키워드를 자유롭게 입력해주세요.</p>
                <textarea id="keywordInput" rows="4" class="w-full p-4 border border-gray-700 rounded-md focus:ring-white/50 focus:border-white/50 text-white placeholder-gray-500" placeholder="예시: '긴장감 넘치는 스릴러', '몽환적인 영상미가 가득한 유럽 영화', '90년대 홍콩 누아르 분위기'" style="background-color: var(--input-bg-color);"></textarea>
                
                <button id="getKeywordRecommendationBtn" class="main-action-btn w-full py-4 rounded-md font-bold text-lg transition duration-300 shadow-xl mt-6 flex items-center justify-center">
                    <span id="keywordBtnText">키워드에 맞는 영화 5편 추천받기</span>
                    <div id="keywordSpinner" class="animate-spin rounded-full h-5 w-5 border-b-2 ml-2 hidden" style="border-bottom-color: var(--accent-text-color);"></div>
                </button>
                <button id="backToKeywordSubSelectionFromDirect" class="text-gray-500 hover:text-gray-400 w-full text-center mt-4 text-xs transition">
                    다른 키워드 입력 방식으로 돌아가기
                </button>
            </div>

            <!-- ========================================================================= -->
            <!-- [G] 2B. KEYWORD 목록 선택 폼 -->
            <!-- ========================================================================= -->
            <div id="selectionForm" class="hidden max-w-4xl mx-auto space-y-6 p-8 rounded-lg modern-block" style="background-color: var(--card-bg-color);">
                <p class="text-gray-300 font-medium text-base border-b border-gray-700 pb-4">원하는 키워드를 **최소 3개 이상** 선택해 주세요. (클릭하면 선택됩니다)</p>
                
                <!-- 키워드 태그가 표시되는 컨테이너 -->
                <div id="keywordTagContainer" class="flex flex-wrap gap-2 p-4 rounded-md border border-gray-700 min-h-[100px]" style="background-color: var(--input-bg-color);">
                    <!-- 키워드 태그 디자인은 CSS 변수와 .keyword-tag 클래스로 제어됩니다. -->
                </div>
                
                <div class="text-center font-semibold text-gray-400 text-base" id="selectedKeywordCount">선택된 키워드: 0개</div>

                <button id="getSelectedRecommendationBtn" class="main-action-btn w-full py-4 rounded-md font-bold text-lg transition duration-300 shadow-xl mt-6 flex items-center justify-center">
                    <span id="selectionBtnText">선택된 키워드 기반 영화 5편 추천받기</span>
                    <div id="selectionSpinner" class="animate-spin rounded-full h-5 w-5 border-b-2 ml-2 hidden" style="border-bottom-color: var(--accent-text-color);"></div>
                </button>
                <button id="backToKeywordSubSelectionFromSelect" class="text-gray-500 hover:text-gray-400 w-full text-center mt-4 text-xs transition">
                    다른 키워드 입력 방식으로 돌아가기
                </button>
            </div>


            <!-- ========================================================================= -->
            <!-- [H] 추천 결과 출력 블록 (흰색 레이아웃) -->
            <!-- ========================================================================= -->
            <div id="recommendationOutput" class="mt-12 p-8 bg-white text-gray-900 rounded-lg shadow-2xl hidden">
                <!-- 
                    - mt-12: 상단 마진
                    - p-8: 내부 패딩
                    - bg-white: 배경색 흰색 (고정)
                    - text-gray-900: 글자색 짙은 회색 (고정)
                    - rounded-lg: 모서리 둥글기
                    - shadow-2xl: 그림자 효과
                -->
                
                <h4 class="text-3xl font-bold text-gray-900 mb-6 uppercase">✨ 추천 결과</h4>
                
                <div id="aiRecommendationContent" class="leading-relaxed whitespace-pre-wrap text-gray-700 text-base">
                    <!-- 영화 추천 내용이 여기에 표시됩니다. -->
                </div>
                
                <!-- 2. 출처 정보 -->
                <div id="aiSources" class="mt-6 text-sm text-gray-500 font-light">
                    <!-- 검색 출처가 여기에 표시됩니다. -->
                </div>
            </div>
            
        </div>

    <!-- Application Logic -->
    <script type="module">
        const API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent";
        
        // --- 🔑 API KEY 설정 (필수) ---
        // 🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨
        const API_KEY = "AIzaSyDsEmoqYmgJAn6r_Gtrc6rKUkqalvV5gEY"; // 캔버스 환경에서 자동 제공됨
        // 👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆
        
        // --- DOM ELEMENTS ---
        const selectionView = document.getElementById('selectionView');
        const serviceView = document.getElementById('serviceView');
        const serviceTitle = document.getElementById('serviceTitle');
        const loading = document.getElementById('loading');
        const loadingText = document.getElementById('loadingText');
        const recommendationOutput = document.getElementById('recommendationOutput');
        const aiRecommendationContent = document.getElementById('aiRecommendationContent');
        const aiSources = document.getElementById('aiSources');
        const backToSelection = document.getElementById('backToSelection');
        
        // Vibe/History Elements
        const selectVibe = document.getElementById('selectVibe'); // Card DIV
        const vibeForm = document.getElementById('vibeForm');
        const vibeInputsContainer = document.getElementById('vibeInputsContainer'); // 입력 필드 컨테이너
        const addVibeMovieInputBtn = document.getElementById('addVibeMovieInputBtn'); // 입력 필드 추가 버튼
        const getVibeRecommendationBtn = document.getElementById('getVibeRecommendationBtn');

        // Keyword Elements
        const selectKeyword = document.getElementById('selectKeyword'); // Card DIV
        const keywordSubSelectionView = document.getElementById('keywordSubSelectionView');
        const selectDirectInput = document.getElementById('selectDirectInput');
        const selectKeywordList = document.getElementById('selectKeywordList');
        
        // Keyword Direct Input Elements
        const keywordForm = document.getElementById('keywordForm');
        const keywordInput = document.getElementById('keywordInput');
        const getKeywordRecommendationBtn = document.getElementById('getKeywordRecommendationBtn');
        const backToKeywordSubSelectionFromDirect = document.getElementById('backToKeywordSubSelectionFromDirect');

        // Keyword Selection List Elements
        const selectionForm = document.getElementById('selectionForm');
        const keywordTagContainer = document.getElementById('keywordTagContainer');
        const selectedKeywordCount = document.getElementById('selectedKeywordCount');
        const getSelectedRecommendationBtn = document.getElementById('getSelectedRecommendationBtn');
        const backToKeywordSubSelectionFromSelect = document.getElementById('backToKeywordSubSelectionFromSelect');

        // State
        let selectedKeywords = new Set();

        // --- UTILITY FUNCTIONS ---
        
        // Hides all service views and shows only the target view
        function showView(target) {
            [vibeForm, keywordSubSelectionView, keywordForm, selectionForm, loading, recommendationOutput].forEach(el => el.classList.add('hidden'));
            if (target) {
                target.classList.remove('hidden');
            }
        }

        function setLoading(isLoading, text = "영화 데이터를 분석 중입니다...") {
            if (isLoading) {
                selectionView.classList.add('hidden');
                serviceView.classList.remove('hidden');
                showView(loading);
                loadingText.textContent = text;
            } else {
                loading.classList.add('hidden');
            }
        }

        // --- KEYWORD DATA & RENDER ---
        
        const ALL_KEYWORDS = [
            "액션", "스릴러", "SF", "판타지", "드라마", "코미디", "로맨스", "느와르", 
            "범죄", "공포(호러)", "미스터리", "전쟁", "뮤지컬", "다큐멘터리", "애니메이션",
            "서부극", "무협", "첩보", "재난", "실험 영화",
            "복수", "성장", "반전", "음모론", "디스토피아", "휴머니즘", "가족", "역사", 
            "정치", "법정", "종교", "환경", "스포츠", "시간 여행", "인공지능", "SF 스릴러", 
            "학교 폭력", "사회 비판", "블랙 코미디", "실화 기반", "정체성 탐구", "예술가", 
            "청소년", "우주", "초자연", "음악", "셰익스피어 각색", "액션 코미디",
            "아름다운 영상미", "슬픈", "잔혹한", "가슴 따뜻한", "철학적인", "유쾌한", 
            "B급 감성", "몽환적인", "긴장감 넘치는", "힐링", "고전미", "키치", "강렬한", 
            "잔잔한", "컬러풀한", "흑백", "핸드헬드", "옴니버스식", "병맛", "극적인", 
            "퇴폐적인", "미니멀리즘", "느린 호흡", "패셔너블한", "독특한 캐릭터", 
            "음향 효과 강조", "시각 효과 극대화",
            "한국 영화", "미국 영화", "유럽 영화", "아시아 영화", "80년대", "90년대", 
            "2000년대", "최신작", "독립영화", "영국 영화", "프랑스 영화", "일본 영화", 
            "중국 영화", "러시아 영화", "남미 영화", "호주 영화", "1950년대", "1960년대", 
            "1970년대", "2010년대", "2020년대", "판타지 블록버스터", "숨겨진 명작", "단편 영화"
        ];
        // --- END OF KEYWORD DATA ---

        function renderKeywords() {
            keywordTagContainer.innerHTML = '';
            ALL_KEYWORDS.forEach(keyword => {
                const tag = document.createElement('span');
                tag.textContent = keyword;
                tag.className = 'keyword-tag inline-block px-4 py-2 text-sm font-medium rounded-full hover:bg-gray-800 transition duration-150 ease-in-out';
                tag.dataset.keyword = keyword;
                
                if (selectedKeywords.has(keyword)) {
                    tag.classList.add('selected');
                }

                tag.addEventListener('click', () => toggleKeyword(keyword, tag));
                keywordTagContainer.appendChild(tag);
            });
            updateSelectedCount();
        }

        function toggleKeyword(keyword, tag) {
            if (selectedKeywords.has(keyword)) {
                selectedKeywords.delete(keyword);
                tag.classList.remove('selected');
            } else if (selectedKeywords.size < 8) {
                selectedKeywords.add(keyword);
                tag.classList.add('selected');
            } else {
                // Custom alert message
                aiRecommendationContent.innerHTML = '<p class="text-red-500 font-bold">⚠️ 경고: 키워드는 최대 8개까지만 선택할 수 있습니다.</p>';
                recommendationOutput.classList.remove('hidden');
                showView(recommendationOutput);
                setTimeout(() => {
                    showView(selectionForm);
                }, 3000);
            }
            updateSelectedCount();
        }

        function updateSelectedCount() {
            selectedKeywordCount.textContent = `선택된 키워드: ${selectedKeywords.size}개`;
        }
        
        // --- API CALL LOGIC (Text) ---
        
        async function callGeminiApi(systemPrompt, userQuery) {
            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                tools: [{ "google_search": {} }], // Enable grounding
                systemInstruction: { parts: [{ text: systemPrompt }] },
            };

            const MAX_RETRIES = 3;
            for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
                try {
                    const response = await fetch(`${API_URL}?key=${API_KEY}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                         if (response.status === 403) {
                            throw new Error("403 Forbidden: API Key 권한 문제 또는 잘못된 키입니다.");
                        }
                        const errorBody = await response.json();
                        throw new Error(`API 호출 실패 (Status: ${response.status}, Detail: ${JSON.stringify(errorBody)}`);
                    }

                    const result = await response.json();
                    const candidate = result.candidates?.[0];

                    if (candidate && candidate.content?.parts?.[0]?.text) {
                        const text = candidate.content.parts[0].text;
                        const sources = getGroundingSources(candidate);
                        return { text, sources };
                    }
                    throw new Error("API 응답에서 유효한 텍스트를 찾을 수 없습니다.");

                } catch (error) {
                    console.error(`Attempt ${attempt + 1} failed:`, error.message);
                    if (attempt === MAX_RETRIES - 1) {
                         if (error.message.includes("403 Forbidden")) {
                            aiRecommendationContent.innerHTML = '<p class="text-red-500 font-bold">🚨 추천 실패: API 호출에 문제가 발생했습니다. 키를 확인해 주세요.</p>';
                        } else {
                            aiRecommendationContent.innerHTML = `<p class="text-red-500 font-bold">🚨 추천 실패: API 호출에 문제가 발생했습니다. (${error.message}) 잠시 후 다시 시도해 주세요.</p>`;
                        }
                        setLoading(false);
                        recommendationOutput.classList.remove('hidden');
                        return null;
                    }
                    await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
                }
            }
        }
        
        function getGroundingSources(candidate) {
            const sources = [];
            const groundingMetadata = candidate.groundingMetadata;
            if (groundingMetadata && groundingMetadata.groundingAttributions) {
                groundingMetadata.groundingAttributions
                    .map(attribution => ({
                        uri: attribution.web?.uri,
                        title: attribution.web?.title,
                    }))
                    .filter(source => source.uri && source.title)
                    .forEach(source => sources.push(source));
            }
            return sources;
        }

        // --- MARKDOWN & RENDERING ---
        
        // Basic Markdown formatter for text blocks
        function formatMarkdown(text) {
            if (!text) return '';
            
            text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            
            text = text.replace(/\n\* (.*)/g, '\n<li>$1</li>');
            text = text.replace(/(\n<li>.*<\/li>)/g, '<ul class="list-disc list-inside mb-4 pl-4">$1</ul>');
            
            text = text.replace(/\n/g, '<br>');

            return text;
        }

        // Formatter that identifies movie sections and extracts the title to generate the search URL
        function formatRecommendationText(text) {
            if (!text) return '';
            
            // 1. 첫 번째 ###를 기준으로 도입부와 영화 목록을 분리
            const firstMovieIndex = text.indexOf('### ');
            let introText = '';
            let movieSections = text;
            
            if (firstMovieIndex > -1) {
                introText = text.substring(0, firstMovieIndex).trim();
                movieSections = text.substring(firstMovieIndex).trim();
            }

            let html = '';
            
            // 2. 도입부 포맷팅 및 여백 최소화 (mb-2로 최소화)
            if (introText) {
                 // mb-2로 상단 여백을 최소화
                html += `<p class="mb-2 font-normal text-gray-800">${formatMarkdown(introText)}</p>`;
            }
            
            // 3. 영화 섹션 분리 및 포맷팅
            const sections = movieSections.split(/^### /gm).filter(s => s.trim() !== '');

            sections.forEach((section, index) => {
                const titleMatch = section.match(/^(.*?)\n/);
                const rawTitleWithNumber = titleMatch ? titleMatch[1].trim() : `추천 영화 ${index + 1}`;
                
                // 이전 버전의 [SEARCH_URL:...] 태그를 제거하는 로직. 이제 LLM은 이 태그를 생성하지 않습니다.
                const urlPattern = /\[SEARCH_URL:(.*?)\]/;
                let movieContent = section.substring(titleMatch ? titleMatch[0].length : 0);
                if (movieContent.match(urlPattern)) {
                    movieContent = movieContent.replace(movieContent.match(urlPattern)[0], '').trim();
                }

                
                // 제목에서 한국어 제목과 (영어 제목)을 추출
                const titleRegex = /^(?:[0-9]+\.\s*)?(.*?)\s*\((.*?)\)$/;
                const fullTitleMatch = rawTitleWithNumber.match(titleRegex);

                let koreanTitle = rawTitleWithNumber;
                let englishTitle = '';

                if (fullTitleMatch) {
                    // [번호.]와 공백을 제거하고 순수한 한국어 제목만 추출
                    koreanTitle = fullTitleMatch[1].trim().replace(/^[0-9]+\.\s*/, ''); 
                    englishTitle = fullTitleMatch[2].trim();
                } else {
                    // 한국어 제목만 있을 경우, 형식에 맞지 않더라도 사용
                    koreanTitle = rawTitleWithNumber.trim().replace(/^[0-9]+\.\s*/, '');
                }

                // [핵심: 검색 기능 수정 부분] 한국어 제목을 이용해 구글 검색 URL을 동적으로 생성합니다.
                const googleSearchBase = 'https://www.google.com/search?q=';
                // 검색 정확도를 위해 ' 영화'를 추가하고 URL 인코딩합니다.
                const encodedTitle = encodeURIComponent(koreanTitle + ' 영화'); 
                const searchUrl = googleSearchBase + encodedTitle;

                
                movieContent = formatMarkdown(movieContent);
                
                // 영화 추천 항목별 디자인 설정
                const topMarginClass = index === 0 ? 'mt-2' : 'mt-6';
                const borderClass = index === 0 ? '' : 'pt-4 border-t border-gray-300';
                
                html += `
                    <div class="movie-recommendation-item ${topMarginClass} mb-6 ${borderClass}">
                        <h3 class="text-2xl font-bold text-gray-900 mb-2">
                            <div class="flex items-center justify-between flex-wrap gap-y-2">
                                <!-- 제목 블록 -->
                                <div class="title-block">
                                    <span class="korean-title block text-xl font-bold">${koreanTitle}</span>
                                    <span class="english-title block text-lg font-normal text-gray-600">${englishTitle}</span>
                                </div>
                                
                                <!-- 검색 버튼: 동적으로 생성된 searchUrl 사용 -->
                                <a href="${searchUrl}" target="_blank" class="search-btn text-sm px-3 py-1 rounded-full bg-gray-400 text-gray-800 hover:bg-gray-500 transition duration-150 flex items-center whitespace-nowrap ml-4">
                                    <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>
                                    검색
                                </a>
                            </div>
                        </h3>
                        ${movieContent}
                    </div>
                `;
            });
            return html;
        }


        async function displayRecommendation(result) {
            setLoading(false);
            showView(recommendationOutput);

            aiRecommendationContent.innerHTML = formatRecommendationText(result.text);

            aiSources.innerHTML = '출처: ';
            if (result.sources.length > 0) {
                const sourceLinks = result.sources.map((src, index) => 
                    `<a href="${src.uri}" target="_blank" class="text-blue-600 hover:text-blue-800 transition underline">${src.title || `출처 ${index + 1}`}</a>`
                ).join(' | ');
                aiSources.innerHTML += sourceLinks;
            } else {
                 aiSources.innerHTML += '구글 검색 결과를 활용했습니다.';
            }
            
            window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
        }
        
        // --- DYNAMIC VIBE INPUT LOGIC ---

        // 새로운 입력 필드 생성 함수
        function createNewMovieInput() {
            const inputCount = vibeInputsContainer.querySelectorAll('[data-movie-input]').length + 1;
            const input = document.createElement('input');
            
            input.type = 'text';
            input.placeholder = `좋아하는 영화 ${inputCount} (선택)`;
            input.className = 'vibe-movie-input w-full p-4 border border-gray-700 rounded-md focus:ring-white/50 focus:border-white/50 text-white placeholder-gray-500';
            input.style.backgroundColor = 'var(--input-bg-color)';
            input.setAttribute('data-movie-input', ''); // 쿼리용 마커
            
            vibeInputsContainer.appendChild(input);
            input.focus();
        }


        // --- HANDLERS ---
        
        function handleServiceSelection(service) {
            selectionView.classList.add('hidden');
            serviceView.classList.remove('hidden');
            recommendationOutput.classList.add('hidden');
            
            if (service === 'vibe') {
                serviceTitle.textContent = "시청 기록 기반 (VIBE) 모드";
                showView(vibeForm);
            } else if (service === 'keyword') {
                serviceTitle.textContent = "키워드 기반 (NARROW) 모드";
                showView(keywordSubSelectionView);
            }
        }
        
        selectVibe.addEventListener('click', () => handleServiceSelection('vibe'));
        selectKeyword.addEventListener('click', () => handleServiceSelection('keyword'));
        
        selectDirectInput.addEventListener('click', () => {
            showView(keywordForm);
        });
        selectKeywordList.addEventListener('click', () => {
            showView(selectionForm);
            renderKeywords(); 
        });
        
        backToSelection.addEventListener('click', () => {
            serviceView.classList.add('hidden');
            selectionView.classList.remove('hidden');
            recommendationOutput.classList.add('hidden');
            selectedKeywords.clear();
            
            // VIBE 입력 필드 초기화 (3개로 복원)
            vibeInputsContainer.innerHTML = `
                <input type="text" data-movie-input placeholder="좋아하는 영화 1 (필수)" class="vibe-movie-input w-full p-4 border border-gray-700 rounded-md focus:ring-white/50 focus:border-white/50 text-white placeholder-gray-500" style="background-color: var(--input-bg-color);">
                <input type="text" data-movie-input placeholder="좋아하는 영화 2 (선택)" class="vibe-movie-input w-full p-4 border border-gray-700 rounded-md focus:ring-white/50 focus:border-white/50 text-white placeholder-gray-500" style="background-color: var(--input-bg-color);">
                <input type="text" data-movie-input placeholder="좋아하는 영화 3 (선택)" class="vibe-movie-input w-full p-4 border border-gray-700 rounded-md focus:ring-white/50 focus:border-white/50 text-white placeholder-gray-500" style="background-color: var(--input-bg-color);">
            `;

            keywordInput.value = '';
            renderKeywords();
        });

        backToKeywordSubSelectionFromDirect.addEventListener('click', () => {
            showView(keywordSubSelectionView);
        });

        backToKeywordSubSelectionFromSelect.addEventListener('click', () => {
            showView(keywordSubSelectionView);
        });
        
        // VIBE 입력 필드 추가 버튼 이벤트 리스너
        addVibeMovieInputBtn.addEventListener('click', createNewMovieInput);

        // Vibe/History recommendation request (기능 코드)
        getVibeRecommendationBtn.addEventListener('click', async () => {
            // 모든 영화 입력 필드에서 값을 수집
            const allInputs = vibeInputsContainer.querySelectorAll('[data-movie-input]');
            const movies = Array.from(allInputs)
                                .map(input => input.value.trim())
                                .filter(t => t); // 빈 문자열 제거

            // 유효성 검사: 최소 1개의 영화 제목이 필요함 (수정됨)
            if (movies.length < 1) { 
                aiRecommendationContent.innerHTML = '<p class="text-red-500 font-bold">⚠️ 경고: 최소 1개의 영화 제목을 입력해야 합니다.</p>'; 
                recommendationOutput.classList.remove('hidden'); 
                showView(recommendationOutput); // 에러 메시지 표시 후 폼 뷰로 돌아감
                return; 
            }
            
            setLoading(true, `[${movies.join(', ')}] 영화들의 분위기를 분석하고 있습니다...`); recommendationOutput.classList.add('hidden');
            const movieString = movies.join(', ');
            // LLM에게 검색 링크를 만들지 말고, 깔끔하게 제목과 설명만 달라고 요청했습니다.
            const systemPrompt = `당신은 세계 최고의 영화 큐레이터입니다. 한국어로 응답해야 하며, 사용자가 제공한 영화 ${movies.length}편을 분석하여 그들의 공통된 분위기(vibe), 장르, 주제를 완벽하게 만족시키는 새로운 영화 5편을 추천해 주세요. 1. 추천하는 영화 5편은 사용자가 이미 제공한 영화들과는 다른 영화여야 합니다. 2. 각 추천 영화 제목은 항상 '###'로 시작해야 하며, **반드시 '### [번호]. [한국어 제목] ([영어 제목])' 형식으로 제공해야 합니다.** (예: '### 1. 기생충 (Parasite)'). 3. 영화 설명에는 절대로 검색 링크나 URL을 삽입하지 마세요.`;
            const userQuery = `이전에 시청한 영화: ${movieString}. 이 영화들의 분위기와 공통점을 바탕으로 다른 영화 5편을 추천해 주세요.`;

            const result = await callGeminiApi(systemPrompt, userQuery);
            if (result) {
                displayRecommendation(result);
            }
        });

        // Keyword Direct Input recommendation request (기능 코드)
        getKeywordRecommendationBtn.addEventListener('click', async () => {
            const keyword = keywordInput.value.trim();
            
            if (!keyword) {
                aiRecommendationContent.innerHTML = '<p class="text-red-500 font-bold">⚠️ 경고: 원하는 키워드를 입력해야 합니다.</p>';
                recommendationOutput.classList.remove('hidden'); 
                showView(recommendationOutput);
                return;
            }

            setLoading(true, `[${keyword}] 키워드에 맞는 영화를 검색 중입니다...`); recommendationOutput.classList.add('hidden');
            // LLM에게 검색 링크를 만들지 말고, 깔끔하게 제목과 설명만 달라고 요청했습니다.
            const systemPrompt = `당신은 세계 최고의 영화 큐레이터입니다. 한국어로 응답해야 하며, 사용자가 제공한 키워드/자유 서술을 바탕으로 가장 적합하고 흥미로운 영화 5편을 추천해 주세요. 1. 각 추천 영화 제목은 항상 '###'로 시작해야 하며, **반드시 '### [번호]. [한국어 제목] ([영어 제목])' 형식으로 제공해야 합니다.** (예: '### 1. 기생충 (Parasite)'). 2. 영화 설명에는 절대로 검색 링크나 URL을 삽입하지 마세요.`;
            const userQuery = `자유 입력 키워드: ${keyword}. 이 키워드에 맞는 영화 5편을 추천해 주세요.`;

            const result = await callGeminiApi(systemPrompt, userQuery);
            if (result) {
                displayRecommendation(result);
            }
        });

        // Keyword Selection List recommendation request (기능 코드)
        getSelectedRecommendationBtn.addEventListener('click', async () => {
            const keywords = Array.from(selectedKeywords);

            if (keywords.length < 3) {
                 aiRecommendationContent.innerHTML = '<p class="text-red-500 font-bold">⚠️ 경고: 영화 추천의 정교함을 위해 최소 3개 이상의 키워드를 선택해야 합니다.</p>'; 
                 recommendationOutput.classList.remove('hidden'); 
                 showView(recommendationOutput);
                 return;
            }

            setLoading(true, `[${keywords.join(', ')}] 키워드 조합에 맞는 영화를 검색 중입니다...`); recommendationOutput.classList.add('hidden');
            const keywordString = keywords.join(', ');
            // LLM에게 검색 링크를 만들지 말고, 깔끔하게 제목과 설명만 달라고 요청했습니다.
            const systemPrompt = `당신은 세계 최고의 영화 큐레이터입니다. 한국어로 응답해야 하며, 사용자가 제공한 키워드 조합을 완벽하게 만족시키는 영화 5편을 추천해 주세요. 1. 각 추천 영화 제목은 항상 '###'로 시작해야 하며, **반드시 '### [번호]. [한국어 제목] ([영어 제목])' 형식으로 제공해야 합니다.** (예: '### 1. 기생충 (Parasite)'). 2. 영화 설명에는 절대로 검색 링크나 URL을 삽입하지 마세요.`;
            const userQuery = `선택된 키워드: ${keywordString}. 이 조합에 맞는 영화 5편을 추천해 주세요.`;

            const result = await callGeminiApi(systemPrompt, userQuery);
            if (result) {
                displayRecommendation(result);
            }
        });

        // Initial setup
        window.onload = () => {
            renderKeywords(); // 키워드 목록을 초기 로드
        };

    </script>
</body>
</html>
